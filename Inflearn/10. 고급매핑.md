# 고급매핑
- 상속관계 매핑
- @MappedSuperclass

## 상속관계 매핑
- 관계형 데이터베이스에서는 상속관계는 미존재
- 슈퍼타입, 서브타입 관계라는 모델링 기법이 객체 상속과 유사
- 상속관계 매핑 : 객체의 상속과 구조와 데이터베이스의 슈퍼타입 및 서브타입 관계를 매핑

## 주요 어노테이션
- @Inheritance(strategy = InheritanceType.????)
  - JOINED : 조인 전략
  - SINGLE_TABLE : 단일 테이블 전략
  - TABLE_PER_CLASS : 구현 클래스마다 
- __주요 어노테이션의 내용을 아래에 코드로 살펴본다.__

## 논리모델을 실제 물리모델로 구현하는 세가지 방법
### 각각 테이블로 변환 -> 조인 전략 (하나의 테이블과 그 하위에 자식 테이블 구성)
![](https://github.com/pasudo123/SoftwareZeroToALL/blob/master/Image/%EC%A1%B0%EC%9D%B8%EC%A0%84%EB%9E%B5.PNG)

#### 조인전략을 적용한 엔티티
- __@Inheritance(strategy = GenerationType.IDENTITY)__
- __@DiscriminatorColumn__
  - Item Entity 에서 DTYPE 컬럼을 생성해주고, 해당 필드에 엔티티 명이 들어간다.
  - DTYPE 컬럼은 'Movie', 'Album', 'Book' 이렇게 올 수 있다.
  - Item 테이블만 확인하는 경우 DTYPE 을 확인해서 판단할 수 있기 때문에 써주는 것이 좋다.
- __@DiscriminatorColumn(name = "")__
  - DTYPE 말고 name 속성을 이용하여 다른 이름을 넣어줄 수 있다.
    - ex) @DiscriminatorColumn(name = "DC_TYPE")
- __@DiscriminatorValue("BlahBlah")__
  - DTYPE 을 엔티티 네임이 아닌 다른 이름으로 명시하고자 하는 경우에 자식 엔티티에서 해당 어노테이션을 사용해준다.

```java

/** 최상위에 Item Entity **/

@Entity
@Table(name = "item")
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int price;
    
}

/** 하위에 Album, Book, Movie Entity **/
@Entity
@Table(name = "album")
public class Album extends Item{

    private String artist;

}

@Entity
@Table(name = "book")
public class Book extends Item {

    private String author;
    private String isbn;

}

@Entity
@Table(name = "movie")
@DiscriminatorValue("moviemovie") // DTYPE 에 해당 값이 삽입된다.
public class Movie extends Item{

    private String director;
    private String actor;

}
```

#### 나타나는 쿼리
```query
Hibernate: 
    
    create table item (
       id bigint generated by default as identity,
        name varchar(255),
        price integer not null,
        primary key (id)
    )

Hibernate: 
    
    create table book (
       author varchar(255),
        isbn varchar(255),
        id bigint not null,
        primary key (id)
    )

Hibernate: 
    
    create table album (
       artist varchar(255),
        id bigint not null,
        primary key (id)
    )

Hibernate: 
    
    create table movie (
       actor varchar(255),
        director varchar(255),
        id bigint not null,
        primary key (id)
    )
    
Hibernate: 
    
    alter table album 
       add constraint FKrl4nl1yn7tatob2buih6y9qws 
       foreign key (id) 
       references item
Hibernate: 
    
    alter table book 
       add constraint FKqk00l5u7w76kq5n45m9h5t5rj 
       foreign key (id) 
       references item
Hibernate: 
    
    alter table movie 
       add constraint FK77hfitoaq24bt17vl2307651e 
       foreign key (id) 
       references item
```

- 하위 엔티티 삽입 시 __두 번의__ Insert 쿼리가 날라간다.
- 하위 엔티티 조회 시 Inner Join 으로 조회한다. (FK 가 PK 로 자리잡고 있기 때문이다.)
  
### 통합 테이블로 변환 -> 단일 테이블 전략 (하나의 테이블 내에 모든 컬럼을 삽입)
![](https://github.com/pasudo123/SoftwareZeroToALL/blob/master/Image/%EB%8B%A8%EC%9D%BC%ED%85%8C%EC%9D%B4%EB%B8%94%EC%A0%84%EB%9E%B5.PNG)

#### 단일 테이블 전략을 사용한 엔티티
- __@Inheritance(strategy = InheritanceType.SINGLE_TABLE)__
- 단일 테이블 전략은 __@DiscriminatorColumn__ 가 없어도 DTYPE 을 생성해준다.

```java

/** 최상위에 Item Entity **/

@Entity
@Table(name = "item")
@Setter
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int price;

}

```

#### 나타나는 쿼리
```query
Hibernate: 
    
    create table item (
       DTYPE varchar(31) not null,
        id bigint generated by default as identity,
        name varchar(255),
        price integer not null,
        author varchar(255),
        isbn varchar(255),
        artist varchar(255),
        actor varchar(255),
        director varchar(255),
        primary key (id)
    )
```

- 하위 엔티티 삽입 시 __한 번의__ Insert 쿼리가 날라간다.

### 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략 (각각의 테이블로 구헌)
![](https://github.com/pasudo123/SoftwareZeroToALL/blob/master/Image/%EA%B5%AC%ED%98%84%ED%85%8C%EC%9D%B4%EB%B8%94%20%EC%A0%84%EB%9E%B5.PNG)

#### 구현 클래스마다 테이블 전략을 사용한 엔티티
- __@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)__
- 최상위 Entity 인 Item Class 를 추상클래스로 만들어준다.

```java
@Entity
@Table(name = "item")
@Setter
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item {

    @Id
    @GeneratedValue
    private Long id;

    private String name;
    private int price;

}
```

#### 나타나는 쿼리
```query
Hibernate: 
    
    create table album (
       id bigint not null,
        name varchar(255),
        price integer not null,
        artist varchar(255),
        primary key (id)
    )
Hibernate: 
    
    create table book (
       id bigint not null,
        name varchar(255),
        price integer not null,
        author varchar(255),
        isbn varchar(255),
        primary key (id)
    )
Hibernate: 
    
    create table movie (
       id bigint not null,
        name varchar(255),
        price integer not null,
        actor varchar(255),
        director varchar(255),
        primary key (id)
    )
```

- Item 엔티티의 컬럼값들을 각각의 엔티티의 컬럼에 속한다.
- JPA 는 Union 연산을 사용해서 PK 를 다 확인한다. 

### 각각의 장단점
#### 조인전략
- 데이터가 정규화가 되어있다.
- 제약조건을 최상위 엔티티에 걸어서 맞출 수 있다.
- 외래키 참조 무결성 제약조건을 활용할 수 있다. ( 자식 엔티티가 FK = PK ) 로 식별관계에 속해있다.
- 저장공간의 효율화
  - 정규화가 되어있기 때문
- 조회시 조인을 많이 사용된다. 성능 저하
- 조회 쿼리가 복잡하다.
- 데이터 저장 시, Insert 쿼리가 두 번 발생된다.

#### 단일테이블 전략
- 조인이 필요없다.
- 조회 쿼리가 단순하다.
- 자식 엔티티의 매핑한 컬럼을 가지고 있기 때문에 null 이 허용된다.
- 단일 테이블의 모든 컬럼을 넣기 때문에 테이블이 커질 경우가 있다.

#### 구현클래스마다 테이블 전략
- __사용하면 안되는 전략__
- 여러 테이블을 함께 조회하는 경우 union 연산이 들어간다. 성능 저하

## @MappedSuperclass
- 공통된 매핑정보가 필요한 경우 사용한다.
  - @CreatedDate 또는 @LastModifiedDate 를 생각해볼 수 있다.
  - 생성날짜와 마지막 수정날짜에 대해서 공통된 컬럼은 거의 모든 엔티티에서 필요로 한다.
- 상속관계 매핑이 아니다.
- 엔티티가 아니며 테이블과 매핑시키지 않는다.
- 부모 클래스를 상속받는 자식 클래스에 매핑 정보만 제공
- 직접 생성해서 사용할 일이 없기 때문에 __추상클래스를 권장__ 한다. (abstract)

```java
@MappedSuperclass
public abstract class BaseEntity {

    private LocalDateTime createdDate;
    private LocalDateTime lastModifiedDate;

}


@Entity
@Table(name = "article")
public class Article extends BaseEntity {

    @Id
    @GeneratedValue
    private Long id;

    @Column(name = "text", columnDefinition = "TEXT")
    private String text;
}
```

- 테이블과 전혀 관계가 없다. 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할이다.
- 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.
- JPA 상에서 extends 키워드를 사용하기 위해선 @Entity 또는 @MappedSuperclass 어노테이션이 달려있어야 한다.
