# 값 타입 컬렉션
- 값 타입을 하나 이상 저장할 때 사용 (값 타입을 컬렉션으로 쓰는 것)
- @ElementCollection 과 @CollectionTable 을 사용
- 데이터베이스 컬렉션을 같은 테이블에 저장할 수 없다.
- 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.

![](https://github.com/pasudo123/SoftwareZeroToALL/blob/master/Image/value-type-collection.png)
- 멤버 테이블에서 값 타입을 두 개 가지고 있다.
- 여기서 값 타입이 컬렉션으로 들어가 있다.

### Member Table
```java
@Entity
@Setter
@Getter
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "member_id")
    private Long id;

    @Column(name = "username")
    private String username;

    @Embedded
    private Address address;

    @ElementCollection
    @CollectionTable(
            name = "favorite_food",
            joinColumns = {@JoinColumn(name = "member_id")}
    )
    @Column(name = "food_name")
    private Set<String> favoriteFoods = new HashSet<>();

    @ElementCollection
    @CollectionTable(
            name = "address",
            joinColumns = {@JoinColumn(name = "member_id")}
    )
    private List<Address> addressHistory = new ArrayList<>();
}
```

### Address Table
```java
@Embeddable
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@ToString
@EqualsAndHashCode
public class Address {

    private String city;
    private String street;
    private String zipcode;

}
```

### 생성되는 테이블 내용.
```java
Hibernate: 
    
    create table Member (
       member_id bigint generated by default as identity,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255),
        username varchar(255),
        primary key (member_id)
    )
    
Hibernate: 
    
    create table address (
       member_id bigint not null,
        city varchar(255),
        street varchar(255),
        zipcode varchar(255)
    )
       
Hibernate: 
    
    create table favorite_food (
       member_id bigint not null,
        food_name varchar(255)
    )
    
Hibernate: 
    
    alter table address 
       add constraint FK6ncq4527mw0seu2b7wr19mqpg 
       foreign key (member_id) 
       references Member
Hibernate: 
    
    alter table favorite_food 
       add constraint FKetdr9m6ysgxkvs2f7vf15sac4 
       foreign key (member_id) 
       references Member
```

### 데이터 삽입하기. (INSERT)
```java
/** 트랜잭션 수행 **/
tx.begin();

try{

    Member member = new Member();

    // 일반 값 타입
    member.setUsername("홍길동");
    member.setAddress(new Address("서울", "남부순환로", "어느 구간의 길"));

    // 값 타입 컬렉션
    member.getFavoriteFoods().add("고구마 피자");
    member.getFavoriteFoods().add("포테이토 피자");
    member.getFavoriteFoods().add("쉬림프 피자");

    // 값 타입 컬렉션
    member.getAddressHistory().add(new Address("통영", "화포면 2길", "화포면 어느 길"));
    member.getAddressHistory().add(new Address("충주", "대학로 20길", "대학가 어느 길"));

    /**
     * 멤버 테이블을 저장할 때,
     * FavoriteFood Table, Address Table 에 같이 값이 들어간다.
     * 이렇게 들어가는 이유는 두 테이블 모두 값 타입이기 떄문이다.
     *
     * 값 타입 컬렉션은 라이프 사이클은 멤버 테이블의 생명주기에 소속된다.
     */
    entityManager.persist(member);

    tx.commit();
```
#### 값 타입 컬렉션은 영속성 전이와 고아객체 제거 기능을 필수로 가진다고 볼 수 있다.

### 데이터 조회하기. (SELECT)
- 값 타입 리스트는 지연로딩 전략을 따른다. 아래와 같이 작성하고 하이버네이트 SQL 문 출력을 살펴보면 아래와 같이 나타난다.
```java
entityManager.persist(member);
entityManager.flush();
entityManager.clear();

System.out.println("=========================================");

/** 값 타입 컬렉션은 지연로딩 전략을 사용한다. **/
Member foundMember = entityManager.find(Member.class, 1L);

System.out.println("========= 내가 가장 좋아하는 과일 출력하기");
for(String fruit : foundMember.getFavoriteFoods()) {
    System.out.println(String.format("==> %s", fruit));
}

System.out.println();
System.out.println("========= 내가 가지고 있는 주소 출력하기");
for(Address address : foundMember.getAddressHistory()) {
    System.out.println(String.format("==> %s", address.toString()));
}

tx.commit();
```

### 출력되는 SQL 문.
```java
=========================================
Hibernate: 
    select
        member0_.member_id as member_i1_6_0_,
        member0_.city as city2_6_0_,
        member0_.street as street3_6_0_,
        member0_.zipcode as zipcode4_6_0_,
        member0_.username as username5_6_0_ 
    from
        Member member0_ 
    where
        member0_.member_id=?
========= 내가 가장 좋아하는 과일 출력하기
Hibernate: 
    select
        favoritefo0_.member_id as member_i1_4_0_,
        favoritefo0_.food_name as food_nam2_4_0_ 
    from
        favorite_food favoritefo0_ 
    where
        favoritefo0_.member_id=?
==> 고구마 피자
==> 포테이토 피자
==> 쉬림프 피자

========= 내가 가지고 있는 주소 출력하기
Hibernate: 
    select
        addresshis0_.member_id as member_i1_0_0_,
        addresshis0_.city as city2_0_0_,
        addresshis0_.street as street3_0_0_,
        addresshis0_.zipcode as zipcode4_0_0_ 
    from
        address addresshis0_ 
    where
        addresshis0_.member_id=?
==> Address(city=통영, street=화포면 2길, zipcode=화포면 어느 길)
==> Address(city=충주, street=대학로 20길, zipcode=대학가 어느 길)
```

### 데이터 수정하기. (UPDATE)
- 값 타입에 대한 컬렉션 업데이틀 수행하기 위해서는 remove 이후 add 를 수행한다.
```java
System.out.println("=========================================");
System.out.println("========= 고구마 피자를 치킨으로 수정한다.");
/** 값 타입 컬력션 수정 (삭제 후 삽입) **/
foundMember.getFavoriteFoods().remove("고구마 피자");
foundMember.getFavoriteFoods().add("양념통닭");
```

### 출력되는 SQL 문.
```
=========================================
========= 고구마 피자를 치킨으로 수정한다.
Hibernate: 
    /* delete collection row jpabook.valuetype.Member.favoriteFoods */ delete 
        from
            favorite_food 
        where
            member_id=? 
            and food_name=?
Hibernate: 
    /* insert collection
        row jpabook.valuetype.Member.favoriteFoods */ insert 
        into
            favorite_food
            (member_id, food_name) 
        values
            (?, ?)
```

- __값 타입이 임베디드 타입으로 표현된 경우, Equals 랑 Hashcode() 가 올바르게 구현__ 되어 있어야만 제대로 수행된다.
- 아래의 내용을 보면 임베디트 타입 Address 는 롬복으로 Equals 랑 HashCode 가 구현되어 있다.
- 

```java
System.out.println("=========================================");
System.out.println("========= 주소를 충주에서 제천으로 변경한다.");

// 존재하는 데이터
foundMember.getAddressHistory().remove(new Address("충주", "대학로 20길", "대학가 어느 길"));

// 새롭게 넣을 데이터
foundMember.getAddressHistory().add(new Address("제천", "제천 180길", "숲속 어느 길"));

tx.commit();



=========================================
========= 주소를 충주에서 제천으로 변경한다.
Hibernate: 
    select
        addresshis0_.member_id as member_i1_0_0_,
        addresshis0_.city as city2_0_0_,
        addresshis0_.street as street3_0_0_,
        addresshis0_.zipcode as zipcode4_0_0_ 
    from
        address addresshis0_ 
    where
        addresshis0_.member_id=?
Hibernate: 
    /* delete collection jpabook.valuetype.Member.addressHistory */ delete 
        from
            address 
        where
            member_id=?
Hibernate: 
    /* insert collection
        row jpabook.valuetype.Member.addressHistory */ insert 
        into
            address
            (member_id, city, street, zipcode) 
        values
            (?, ?, ?, ?)
Hibernate: 
    /* insert collection
        row jpabook.valuetype.Member.addressHistory */ insert 
        into
            address
            (member_id, city, street, zipcode) 
        values
            (?, ?, ?, ?)
```

## 값 타입 컬렉션 제약사항
- 값 타입은 엔티티와 다르게 식별자의 개념이 없다.
- 값은 변경하면 추적이 어렵다.
- 값 타입 컬렉션에 변경사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 
    - 위에서 Address 를 하나 remove() 헀고 add() 를 한 경우, 한 번 delete 이후에 두 번의 insert 가 그러한 이유이다.
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키로 구성하여야 한다.null 입력 X, 중복저장 X

# 결론적으로 말하면 값 타입 컬렉션은 사용하면 위험하다. 만약 쓰려고 한다면 결과적으로 null 입력 허용시키면 안되고, 중복저장을 허용시키면 안된다. 모두 PK 로 구성한다. 그리고 실무에서는 값 타입 컬렉션 대신에 일대다 관계를 사용하는 것으로 고려한다.

### 값 타입 컬렉션 대안. (엔티티로 값 타입을 래핑한다.)
```java
@Entity
@Getter
@Setter
public class AddressEntity {

    @Id
    @GeneratedValue
    private Long id;

    private Address address;
    
}
```

## 정리
- 엔티티 타입 특징
    1. 식별자 존재
    2. 생명 주기 관리
    3. 공유
- 값 타입 특징
    1. 식별자 미존재
    2. 생명주기를 엔티티에 의존
    3. 공유하지 않는 것이 안전 (복사해서 사용)
    4. 불변객체로 만드는 것이 안전

## 식별자가 필요하고 지속해서 값을 추적 및 변경해야 하는 경우, 그것은 값 타입이 아닌 식별자이다.
