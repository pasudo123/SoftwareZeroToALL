# Database Index
Database Index 개념 정리.

<BR>

## Index 에 알아보기에 앞서서 알아야 하는 내용
* __테이블__
  * 데이터베이스 내에 존재하는 대표적인 개체
  * 시스템 테이블과 사용자 테이블이 존재
  * 실제 데이터를 물리적으로 포함하고 있음
  * 행(row) & 열(column) 으로 구성
* __페이지__
  * 데이터 파일을 구성하는 논리단위
  * 기본 데이터의 저장 단위 8KB
  * 데이터를 __쓰는__ 경우 행을 페이지에 기록함
  * 데이터를 __읽는__ 경우 페이지 내의 모든 행이 읽혀짐
  * 페이지내의 행이 많을수록, 즉 레코드가 많을수록 I/O 의 효율이 증가
  * 0 ~ n 사이의 순차적인 번호 => 페이지의 번호
  * 예를들어,
    * 8KB 페이지에 레코드 100개가 있고 100개를 읽으려면 페이지 1개만 읽으면 됨
    * 8KB 페이지에 레코드 10개가 있고 100개를 읽으려면 페이지 10개를 읽어야 함
    * 하나의 페이지에 네 개의 행이 있다는 것은 4개의 레코드가 있음을 의미

<BR>

## Index
* table row 에 하나씩 대응되는 별도의 객체 (object)
* SQL 수행속도를 향상시키기 위해서 고안
* 인덱스가 없다는 것은 모든 데이터에 대해 일일히 데이터 액세스를 하고 있다는 것 (그만큼의 비용이 발생)
* DML 언어에 대해서 인덱스가 필요하다. (SELECT, UPDATE, DELETE)
* [옵티마이저](http://www.gurubee.net/lecture/2400)가 최적의 경로를 결정하기 위해 사용하는 요소 (factor)
* 구성
  * Index = 컬럼의 값 (Value) + 논리적 주소 (Row ID) 결합
* 인덱스는 하나의 테이블에 여러 개를 지정할 수 있고, 하나의 컬럼이 여러 개의 인덱스에 포함될 수 있음
* 테이블과 무관하게 CREATE 또는 DROP 이 독립적으로 가능하다.

<BR>

## 자동인덱스 vs 수동인덱스
* __자동인덱스__ : Primary key 또는 Uninque 제약조건에 의해 자동적으로 생성된 인덱스
* __수동인덱스__ : CREATE INDEX 명령어를 통해서 만든 인덱스

<BR>

## Index 의 장점
* 빠른 데이터 검색
* 데이터의 중복을 방지
* 잠금 최소화
  * 최소 범위의 잠금을 가능하게 해준다.
  * 동시성을 높여준다. 그만큼 많은 사용자가 동시에 데이터를 액세스할 수 있음을 의미함.

<BR>

## Index 의 단점
* 물리적인 공간을 차지, (인덱스도 페이지를 가짐)
  * 인덱스는 테이블 처럼 데이터를 가지며, 페이지가 있음
  * 테이블과 같이 물리적인 공간을 차지
* 인덱스에 대한 유지관리 부담
  * SELECT 문에 효율
  * INSERT 문에 효율이 없음
  * 따라서 데이터가 적다면, 인덱스를 사용하지 않아도 되며 인덱스를 통한 장점보단 유지관리 부담이 클 수 있음

## Index 선정
* 15% 이내의 테이블 자료에 접근할 경우 효율적
* 그 이상의 자료를 접근하는 경우 Full Table Scan 이 효율적
* 테이블의 Row 수가 많은 경우에는 5% 이내의 자료에 접근하는 경우가 효율적일 수 있음
* Index 를 적용해야 하는 테이블
  * 특정 범위/순서의 데이터 조회가 필요한 경우
  * 조인의 연결고리가 되는 컬럼이 있는 경우
  * 일반적 15% 이내의 데이터 요구인 경우
  * 중대형 규모의 테이블 (6블럭 이상)
* 분포도를 따진다.
  * 분포도(%) = `(데이터별 평균 row 수 / 테이블 총 row 수) * 100` 
  * 회원번호, 사원번호, 서비스 접수번호 등은 분포도가 _좋다_ 라고 칭한다.
  * 성별(남/녀) 와 같은 경우는 분포도가 _나쁘다_ 라고 칭한다.

<BR>

## 데이터베이스에서 페이지를 가지는 개체는 딱 두가지가 존재한다.
* __테이블 (Table)__
* __인덱스 (Index)__

<BR>

## Database Heap
* 정렬 기준이 없이 저장된 테이블의 존재형태
  * 데이터 페이지 내의 행들 간에 순서가 없음
  * 데이터 페이지들 간에도 순서가 없음
  * 결과적으로 아무렇게나 쌓아놓은 더미의 형태
* 클러스터 형 인덱스가 없는 테이블을 의미
* INSERT DML 조작어 시, 빈 공간에 그냥 삽입하면 됨
* SELECT DML 조작어 시, 데이터가 많은 경우 원하는 데이터를 찾기가 어려움 (Table Scan)

<BR>

## Clustering Index (클러스터형 인덱스)
* 클러스터형 인덱스는 해당 키 값을 기반으로 테이블이나 뷰의 데이터 행을 정렬하고 저장한다. __Primary Key 에 한하여 적용__ 
* 데이터 행 자체는 한가지 순서로만 저장될 수 있으므로 테이블당 클러스터형 인덱스는 하나만 있을 수 있다.
* 물리적으로 행을 __재배열__
* 인덱스 페이지 용량이 넌클러스터드 인덱스 페이지 용량보다 상대적으로 __작다.__ (데이터베이스 용량을 적게 차지한다.)
* 테이블당 1개

<BR>

## Non Clustering Index (넌클러스터형 인덱스)
* 비클러스터형 인덱스는 데이터 행으로부터 독립적이다. 
* 비클러스터형 인덱스에는 비클러스터형 인덱스 키 값이 있으며 각 키 값 항목에는 해당 키 값이 포함된 데이터 행에 대한 포인터가 있다. 
* 물리적으로 행을 __재배열 하지 않는다.__ 
* 인덱스 페이지 용량이 클러스터드 인덱스 페이지 용량보다 상대적으로 __크다.__ (데이터베이스 용량을 크게 차지한다.)
* 테이블당 249개

### 조회결과의 약 30% 가 선택되는 정도라면, 데이터를 _클러스터드 인덱스_ 로 설정

### 조회결과의 약 3% 내외가 선택되는 정도라면, 데이터를 _넌클러스터 인덱스_ 로 설정

## 결론
* 인덱스는 데이터베이스의 테이블 내 원하는 레코드를 빠르게 찾아갈 수 있도록 만들어진 데이터구조이다. 
* 기본적인 목적은 검색 성능의 최적화

## 참고링크
1. [꿈꾸는 개발자, DBA 커뮤니티 구루비](http://www.gurubee.net/)
2. [Clustered vs. Nonclustered Index Structures in SQL Server](https://www.youtube.com/watch?v=ITcOiLSfVJQ&t=363s)
